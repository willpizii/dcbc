{% extends "base.html" %}

{% block content %}

<style>
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        border: 1px solid black;
        padding: 8px;
        text-align: center;
        cursor: pointer;
        user-select: none;
    }
    th {
        background-color: #f2f2f2;
    }
    .available {
        background-color: #98FB98; /* Light green for available */
    }
    .not-available {
        background-color: #FF6F6F; /* Light red for not available */
    }
    .if-needs-be {
        background-color: #FFFFE0; /* Light yellow for if needs be */
    }
    .button-group {
        margin-bottom: 10px;
    }
    .active-button {
        border: 3px solid black; /* Strong black border */
    }
    #markAvailable {
        background-color: #98FB98; /* Match the 'available' cell color */
        color: black;
    }
    #markNotAvailable {
        background-color: #FF6F6F; /* Match the 'not-available' cell color */
        color: black;
    }
    #markIfNeedsBe {
        background-color: #FFFFE0; /* Match the 'if-needs-be' cell color */
        color: black;
    }
    button {
        border: none;
        padding: 10px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 10px;
    }
    /* Ensures proper alignment and spacing */
    td, th {
        min-width: 100px;
    }
</style>

<div class="container mt-5">
    <div class="p-4 border rounded bg-light">
        <h1 class="mb-4">Fill your Availability</h1>
        <div class="button-group">
            <button id="markAvailable" class='active-button'>Mark as Available</button>
            <button id="markIfRequired">Mark as If Required</button>
            <button id="markNotAvailable">Mark as Not Available</button>
            <button id="markOutOfCam">Mark as Out of Cambridge</button>
        </div>
        <form method="POST" id="availabilityForm" action="/submit_availability">
            <label for="name">Your Name:</label>
            <input type="text" id="name" name="name" hidden value="{{ crsid }}">
            <input type="text" style="cursor: not-allowed;" disabled value="{{ username }}"><br><br>

            <select id="weekSelector" name="month" class="form-select mb-3">
                {% for month in months %}
                    <option value="{{ month }}" {% if month == selected_week %}selected{% endif %}>{{ month }}</option>
                {% endfor %}
            </select>

            <label>Select Times:</label><br>
            <table id="availabilityTable" border="1">
                <thead>
                    <tr>
                        <th></th>
                        {% for day in days_of_week %}
                            <th>{{ day }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for week in day_cells %}
                        <tr>
                            <th>Week {{ loop.index }}</th>
                            {% for day in week %}
                                <td>
                                    {% if day %}
                                        {{ day }}
                                    {% endif %}
                                </td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
            <br>
            <button type="submit">Save Week</button>
        </form>
    </div>
</div>

<script>
    // Define the days of the week for column headers
    const days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

    // Function to get the number of days in a month
    function getDaysInMonth(month, year) {
        return new Date(year, month, 0).getDate();
    }

    // Function to populate the calendar based on the selected month
    function populateCalendar() {
        const monthSelector = document.getElementById('monthSelector');
        const selectedMonth = monthSelector.value;
        const calendarBody = document.getElementById('calendarBody');
        const year = new Date().getFullYear(); // Use the current year

        // Clear previous rows
        calendarBody.innerHTML = '';

        // Determine the number of days in the selected month
        const daysInMonth = getDaysInMonth(new Date(Date.parse(selectedMonth +" 1, 2024")).getMonth() + 1, year);

        // Calculate the number of weeks needed
        const numberOfWeeks = Math.ceil(daysInMonth / 7);

        // Populate the table rows for each week
        for (let week = 0; week < numberOfWeeks; week++) {
            let row = '<tr>';
            row += `<td>Week ${week + 1}</td>`; // Week number

            for (let day = week * 7; day < (week + 1) * 7; day++) {
                if (day < daysInMonth) {
                    row += `<td data-date="${day + 1}">${day + 1}</td>`; // Day of the month
                } else {
                    row += '<td></td>'; // Empty cell for days outside the current month
                }
            }

            row += '</tr>';
            calendarBody.innerHTML += row;
        }
    }

    // Initial population of the calendar
    populateCalendar();
</script>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        let isMouseDown = false;
        let startCell = null;
        const markedCells = new Map(); // Map to track cell state
        const lockedCells = new Set(); // Set to track locked cells

        let markMode = 'available'; // Default mode
        let currentWeek = document.getElementById('weekSelector').value;

        const table = document.getElementById('availabilityTable');
        const form = document.getElementById('availabilityForm');
        const weekSelector = document.getElementById('weekSelector');

        const existingData = {{ existingData|tojson|default('{}')|safe }};

        // Function to update table based on week selection
        function initializeTable() {
            const selectedWeek = weekSelector.value;
            if (!existingData || !existingData.weeks || !existingData.weeks[selectedWeek]) {
                console.warn(`No data found for week ${selectedWeek}`);
                document.querySelectorAll('td[data-time]').forEach(cell => {
                    const time = cell.dataset.time;

                    // Determine the cell's state based on existing data
                    let currentState = 'available'; // Default state
                    // Apply the determined state
                    markedCells.set(time, currentState);
                    cell.classList.remove('available', 'not-available', 'if-needs-be');
                    cell.classList.add(currentState);
                });
                return;
            }

            const weekData = existingData.weeks[selectedWeek];

            document.querySelectorAll('td[data-time]').forEach(cell => {
                const time = cell.dataset.time;

                // Determine the cell's state based on existing data
                let currentState = 'available'; // Default state

                if (weekData['available'] && weekData['available'].includes(time)) {
                    currentState = 'available';
                } else if (weekData['not-available'] && weekData['not-available'].includes(time)) {
                    currentState = 'not-available';
                } else if (weekData['if-needs-be'] && weekData['if-needs-be'].includes(time)) {
                    currentState = 'if-needs-be';
                }

                // Apply the determined state
                markedCells.set(time, currentState);
                cell.classList.remove('available', 'not-available', 'if-needs-be');
                cell.classList.add(currentState);
            });
        }

        initializeTable();

        weekSelector.addEventListener('change', function() {
            currentWeek = weekSelector.value;
            initializeTable();
        });

        // Event listeners for buttons
        const buttons = document.querySelectorAll('.button-group button');

        document.getElementById('markAvailable').addEventListener('click', function() {
            markMode = 'available';
            highlightButton(this);
        });

        document.getElementById('markNotAvailable').addEventListener('click', function() {
            markMode = 'not-available';
            highlightButton(this);
        });

        document.getElementById('markIfNeedsBe').addEventListener('click', function() {
            markMode = 'if-needs-be';
            highlightButton(this);
        });

        function highlightButton(activeButton) {
            buttons.forEach(button => button.classList.remove('active-button'));
            activeButton.classList.add('active-button');
        }

        table.addEventListener('mousedown', function (event) {
            if (event.target.tagName === 'TD' && event.target.dataset.time) {
                isMouseDown = true;
                startCell = event.target;
                toggleCell(event.target);
            }
        });

        table.addEventListener('mouseover', function (event) {
            if (isMouseDown && event.target.tagName === 'TD' && event.target.dataset.time) {
                if (startCell) {
                    if (!lockedCells.has(event.target.dataset.time)) {
                        selectRectangle(startCell, event.target);
                    }
                }
            }
        });

        document.addEventListener('mouseup', function () {
            isMouseDown = false;
            startCell = null;
            lockedCells.clear(); // Clear the lockedCells set when mouse is lifted
        });

        form.addEventListener('submit', function (event) {
            event.preventDefault(); // Prevent the default form submission
            const times = [];

            markedCells.forEach((state, time) => {
                if (state) {
                    times.push(`${time}|${state}`);
                }
            });

            const data = {
                name: form.name.value,
                week: currentWeek,
                times: times
            };

            console.log("Submitting data:", JSON.stringify(data)); // Debugging: Log the data being sent

            const xhr = new XMLHttpRequest();
            xhr.open("POST", form.action, true);
            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');

            xhr.onload = function () {
                if (xhr.status === 200) {
                    window.location.href = xhr.responseURL;
                } else {
                    console.error("Submission failed with status:", xhr.status);
                    console.error("Response text:", xhr.responseText);
                    alert("An error occurred. Please try again.");
                }
            };

            xhr.onerror = function () {
                console.error("Request failed.");
                alert("Failed to send data. Please check your network connection.");
            };

            xhr.send(JSON.stringify(data));
        });

        function toggleCell(cell) {
            const time = cell.dataset.time;
            const currentState = markedCells.get(time);

            if (currentState !== markMode) {
                markedCells.set(time, markMode);
                cell.classList.remove('available', 'not-available', 'if-needs-be');
                cell.classList.add(markMode);
            }
        }

        function selectRectangle(start, end) {
            const startRow = start.parentElement.rowIndex;
            const startCol = start.cellIndex;
            const endRow = end.parentElement.rowIndex;
            const endCol = end.cellIndex;

            // Define the boundaries of the selection
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);

            // Iterate through the cells within the defined rectangle
            for (let i = minRow; i <= maxRow; i++) {
                for (let j = minCol; j <= maxCol; j++) {
                    const cell = table.rows[i].cells[j];
                    if (cell.dataset.time && !lockedCells.has(cell.dataset.time)) {
                        toggleCell(cell);
                    }
                }
            }
        }
    });
</script>

{% endblock %}
